# -*- coding: utf-8 -*-
"""module 4 Sprint 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14gv3foiF-TqS_fO9IIkPXIFnVIiD9eMM
"""

#import libracies
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

# load data
data = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/Question 1/spotifytoptracks.csv')
data.head(5)

# data cleaning
data.info()

# missing value
data.isna().sum()

# remove duplicates
data.duplicated().sum()

data.drop("Unnamed: 0", axis=1, inplace=True)

data.head()

"""# **Outliner**"""

data.describe()

columns = ["energy", "danceability", "key", "loudness", "acousticness",
           "speechiness", "instrumentalness", "liveness", "valence",
           "tempo", "duration_ms"]

n_cols = 3
n_rows = (len(columns) // n_cols) + (1 if len(columns) % n_cols != 0 else 0)

# subplots to display all boxplots
plt.figure(figsize=(15, 10))

# Loop through the columns and create a boxplot for each feature
for i, col in enumerate(columns, 1):
    plt.subplot(n_rows, n_cols, i)
    data[col].plot(kind='box')
    plt.title(f'Boxplot for {col}')

plt.tight_layout()
plt.show()

# drop outliers based on IQR
def drop_outliers_iqr(data, columns):
    for col in columns:
        Q1 = data[col].quantile(0.25)
        Q3 = data[col].quantile(0.75)
        IQR = Q3 - Q1

        # lower and upper bounds for outlier detection
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        # Filter out rows that fall outside the bounds
        data = data[(data[col] >= lower_bound) & (data[col] <= upper_bound)]

    return data
data = drop_outliers_iqr(data, columns)

data.describe()

"""# **Exploratory Data Analysis**"""

print(f"The number of observations is {data.shape[0]} and the number of features is {data.shape[1]}")

# Count of categorical and numeric columns
category = data.select_dtypes(include=['object', 'category']).columns
numeric = data.select_dtypes(include=['number']).columns

# Number of categorical and numeric columns
print(f"The number of categorical columns: {len(category)}")
print(f"The number of numeric columns: {len(numeric)}")

# most popular track
popular_track = data.groupby('artist')['track_name'].count()
artists_rate = popular_track[popular_track > 1]
print(artists_rate)

# Artist most popular
artist = data.groupby('artist')['artist'].count()
most_popular = artist[artist>1]
most_popular

# Total artist in total
num_artists = data['artist'].nunique()
print(f"The number of artists in the top 50 is {num_artists}")

# How many albums in total have their songs in the top 50?
track_count = data.groupby('album')['track_name'].count()
album_count = track_count[track_count].count()
print("The album in the data are ",album_count)

# Count the number of unique albums in the top 50
num_albums= data['album'].nunique()
print(f"The number of albums in the top 50 is {num_albums}")

# tracks with danceability above 0.7
tracks= data[data['danceability'] > 0.7]
print(tracks[['track_name', 'artist', 'danceability']])

# tracks with danceability below 0.4
tracks = data[data['danceability'] < 0.4]
print(tracks[['track_name', 'artist', 'danceability']])

# tracks with loudness above -5
tracks = data[data['loudness'] > -5]
print(tracks[['track_name', 'artist', 'loudness']])

# tracks with loudness above -8
tracks = data[data['loudness'] < -8]
print(tracks[['track_name', 'artist', 'loudness']])

# track with the longest duration
longest = data.loc[data['duration_ms'].idxmax()]
print(f"The longest track is {longest['track_name']} by {longest['artist']} with {longest['duration_ms']}")

# track with the shortest duration
shortest = data.loc[data['duration_ms'].idxmin()]
print(f"The shortest track is {shortest['track_name']} by {shortest['artist']} with {shortest['duration_ms']} ")

#  genre most popular
most_popular_genre = data.groupby('genre')['genre'].max().idxmax()
print(f"The most popular genre is {most_popular_genre}")

# genre with one song on the top 50
genre = data.groupby('genre')['genre'].count()
one_song = genre[genre == 1]
print(one_song)

#count of genres
num_genres = data['genre'].nunique()
print(f"The number of genres in the top 50 is {num_genres}")

# Selecting numeric features
numeric_features = ["energy", "danceability", "key", "loudness", "acousticness",
           "speechiness", "liveness", "valence", "tempo", "duration_ms"]

# Calculating correlation matrix
correlation_matrix = data[numeric_features].corr()

# Plotting correlation heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Heatmap of Numeric Features')
plt.show()

# Strongly positively correlated
positive_corr = correlation_matrix[correlation_matrix > 0.5]
positive_corr = positive_corr[positive_corr != 1]
print("Strongly positively correlated features:")
print(positive_corr.dropna(how='all', axis=1))

# Step 2: Strongly negatively correlated features
negative_corr = correlation_matrix[correlation_matrix < -0.5]
negative_corr = negative_corr[negative_corr != -1]
print("\nStrongly negatively correlated features:")
print(negative_corr.dropna(how='all', axis=1))

# Step 3: Features that are not correlated
no_corr = correlation_matrix[(correlation_matrix > -0.1) & (correlation_matrix < 0.1) & (correlation_matrix != 1)]
print("\nFeatures that are not correlated:")
print(no_corr.dropna(how='all', axis=1))

data['genre'].unique()

# danceability score comparism
genre = ['Pop', 'Hip-Hop/Rap', 'Dance/Electronic', 'Alternative/Indie']
comparism = data_genre.groupby('genre')['danceability'].describe()
comparism  = comparism .loc[:, ['count', 'mean', 'std', 'min', 'max']]
print(comparism )

# loudness score comparism
comparism = data_genre.groupby('genre')['loudness'].describe()
comparism  = comparism .loc[:, ['count', 'mean', 'std', 'min', 'max']]
print(comparism )

# Acousticnes score comparism
comparism = data_genre.groupby('genre')['acousticness'].describe()
comparism  = comparism .loc[:, ['count', 'mean', 'std', 'min', 'max']]
print(comparism )